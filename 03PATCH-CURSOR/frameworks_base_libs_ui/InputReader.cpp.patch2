--- /psquare/developer/ANDROID/CYANOGENMOD7/frameworks/base/libs/ui/InputReader.cpp
+++ /psquare/developer/ANDROID/CYANOGENMOD/frameworks/base/libs/ui/InputReader.cpp
@@ -205,6 +205,55 @@
     configureExcludedDevices();
     updateGlobalMetaState();
     updateInputConfiguration();
+
+    mPadmouseOn = false;
+
+    // Pad mouse magic key
+    mPadmouseMagicKeyEnable = true;
+    mPadmouseMagicKey = AKEYCODE_POWER;
+
+	char prop[PROPERTY_VALUE_MAX] = {0};
+    property_get("ro.padmouse.leftkey", prop, "power");
+
+    if (strcmp(prop,"none") == 0) {
+        mPadmouseMagicKeyEnable = false;
+    } else if (strcmp(prop,"volume_up") == 0) {
+        mPadmouseMagicKey = AKEYCODE_VOLUME_UP;
+    } else if (strcmp(prop,"volume_down") == 0) {
+        mPadmouseMagicKey = AKEYCODE_VOLUME_DOWN;
+    } else if (strcmp(prop,"menu") == 0) {
+        mPadmouseMagicKey = AKEYCODE_MENU;
+    } else if (strcmp(prop,"home") == 0) {
+        mPadmouseMagicKey = AKEYCODE_HOME;
+    } else if (strcmp(prop, "back") == 0) {
+        mPadmouseMagicKey = AKEYCODE_BACK;
+    } else if (strcmp(prop, "search") == 0) {
+        mPadmouseMagicKey = AKEYCODE_SEARCH;
+    } else if (strcmp(prop, "camera") == 0) {
+        mPadmouseMagicKey = AKEYCODE_CAMERA;
+    } else if (strcmp(prop, "power") == 0) {
+        mPadmouseMagicKey = AKEYCODE_POWER;
+    }	else{
+        LOGW("Invalid value for ro.padmouse.leftkey: '%s'",prop);
+    }
+
+	mPadmouseEnable = true;
+	property_get("ro.padmouse.enable", prop, "true");
+	if ( strcmp(prop,"true") != 0) {
+		mPadmouseEnable = false;
+	}
+
+	mDoubleClickEnable = true;
+	property_get("ro.padmouse.doubleclick", prop, "true");
+	if ( strcmp(prop,"true") != 0) {
+		mDoubleClickEnable = false;
+	}
+
+	mPadmouseDebug = false;
+	property_get("ro.padmouse.debug", prop, "false");
+	if ( strcmp(prop,"true") == 0) {
+		mPadmouseDebug = true;
+	}
 }
 
 InputReader::~InputReader() {
@@ -341,6 +390,11 @@
     // Trackball-like devices.
     if (classes & INPUT_DEVICE_CLASS_TRACKBALL) {
         device->addMapper(new TrackballInputMapper(device, associatedDisplayId));
+    }
+
+    // Mouse-like devices.
+    if (classes & INPUT_DEVICE_CLASS_MOUSE) {
+        device->addMapper(new MouseInputMapper(device, associatedDisplayId));
     }
 
     // Touchscreen-like devices.
@@ -522,6 +576,8 @@
 }
 
 void InputReader::setTvOutStatus(bool on){
+    if(mPadmouseEnable)
+        mPadmouseOn = on;
 }
 
 void InputReader::getInputDeviceIds(Vector<int32_t>& outDeviceIds) {
@@ -947,12 +1003,22 @@
     case EV_KEY: {
         int32_t scanCode = rawEvent->scanCode;
         if (isKeyboardOrGamepadKey(scanCode)) {
+//            if(isPadmouseLeftKey(rawEvent->keyCode)){
+//                result = PROCESS_RESULT_PADMOUSE_KEY;
+//                break;
+//            }
             processKey(rawEvent->when, rawEvent->value != 0, rawEvent->keyCode, scanCode,
                     rawEvent->flags);
         }
         break;
     }
     }
+}
+bool KeyboardInputMapper::isPadmouseLeftKey(int32_t scanCode) {
+    if( mContext->isPadmouseOn() && (scanCode == mContext->getPadmouseMagicKey()) )
+        return true;
+    else
+        return false;
 }
 
 bool KeyboardInputMapper::isKeyboardOrGamepadKey(int32_t scanCode) {
@@ -1268,6 +1334,7 @@
     mLocked.surfaceOrientation = -1;
     mLocked.surfaceWidth = -1;
     mLocked.surfaceHeight = -1;
+    mLocked.hwrotation = InputReaderPolicyInterface::ROTATION_0;
 
     initializeLocked();
 }
@@ -1336,6 +1403,8 @@
         dump.appendFormat(INDENT3 "Translation and Scaling Factors:");
         dump.appendFormat(INDENT4 "XOrigin: %d\n", mLocked.xOrigin);
         dump.appendFormat(INDENT4 "YOrigin: %d\n", mLocked.yOrigin);
+        dump.appendFormat(INDENT4 "XRange: %d\n", mLocked.xRange);
+        dump.appendFormat(INDENT4 "YRange: %d\n", mLocked.yRange);
         dump.appendFormat(INDENT4 "XScale: %0.3f\n", mLocked.xScale);
         dump.appendFormat(INDENT4 "YScale: %0.3f\n", mLocked.yScale);
         dump.appendFormat(INDENT4 "XPrecision: %0.3f\n", mLocked.xPrecision);
@@ -1354,7 +1423,14 @@
 void TouchInputMapper::initializeLocked() {
     mCurrentTouch.clear();
     mLastTouch.clear();
+    mPadMouseTouch.clear();
     mDownTime = 0;
+    mUpTime = 0;
+    mLastDownTime = 0;
+
+    mDoubleClick = false;
+    mMagicKeyDown = false;
+    mPadmouseDown = false;
 
     for (uint32_t i = 0; i < MAX_POINTERS; i++) {
         mAveragingTouchFilter.historyStart[i] = 0;
@@ -1450,6 +1526,16 @@
         if (! getPolicy()->getDisplayInfo(mAssociatedDisplayId, & width, & height, & orientation)) {
             return false;
         }
+        char property[PROPERTY_VALUE_MAX];
+        if (property_get("ro.sf.hwrotation", property, NULL) > 0) {
+            mLocked.hwrotation = atoi(property) / 90;
+            if (mLocked.hwrotation == InputReaderPolicyInterface::ROTATION_90 ||
+                    mLocked.hwrotation == InputReaderPolicyInterface::ROTATION_270) {
+                int32_t tmp = width;
+                width = height;
+                height = tmp;
+            }
+        }
     } else {
         orientation = InputReaderPolicyInterface::ROTATION_0;
         width = mRawAxes.x.getRange();
@@ -1473,6 +1559,8 @@
         if (mRawAxes.x.valid && mRawAxes.y.valid) {
             mLocked.xOrigin = mRawAxes.x.minValue;
             mLocked.yOrigin = mRawAxes.y.minValue;
+            mLocked.xRange = mRawAxes.x.getRange();
+            mLocked.yRange = mRawAxes.y.getRange();
             mLocked.xScale = float(width) / mRawAxes.x.getRange();
             mLocked.yScale = float(height) / mRawAxes.y.getRange();
             mLocked.xPrecision = 1.0f / mLocked.xScale;
@@ -1483,6 +1571,8 @@
             LOGW(INDENT "Touch device did not report support for X or Y axis!");
             mLocked.xOrigin = 0;
             mLocked.yOrigin = 0;
+            mLocked.xRange = 0;
+            mLocked.yRange = 0; 
             mLocked.xScale = 1.0f;
             mLocked.yScale = 1.0f;
             mLocked.xPrecision = 1.0f;
@@ -1623,7 +1713,8 @@
     if (orientationChanged || sizeChanged) {
         // Compute oriented surface dimensions, precision, and scales.
         float orientedXScale, orientedYScale;
-        switch (mLocked.surfaceOrientation) {
+        int32_t adjustedorientation = (mLocked.surfaceOrientation + mLocked.hwrotation) % 4;
+        switch (adjustedorientation) {
         case InputReaderPolicyInterface::ROTATION_90:
         case InputReaderPolicyInterface::ROTATION_270:
             mLocked.orientedSurfaceWidth = mLocked.surfaceHeight;
@@ -2071,6 +2162,7 @@
     if (mLastTouch.pointerCount != 0) {
         nsecs_t when = systemTime(SYSTEM_TIME_MONOTONIC);
         mCurrentTouch.clear();
+        mPadMouseTouch.clear();
         syncTouch(when, true);
     }
 
@@ -2128,6 +2220,34 @@
         mLastTouch.clear();
     } else {
         mLastTouch.copyFrom(*savedTouch);
+    }
+}
+
+void TouchInputMapper::computeRelativePosition(){
+    mPadMouseTouch.pointerCount = mCurrentTouch.pointerCount;
+    mPadMouseTouch.idBits = mCurrentTouch.idBits;
+
+    for (uint32_t i = 0; i < mPadMouseTouch.pointerCount; i++) {
+
+        mPadMouseTouch.pointers[i].id = mCurrentTouch.pointers[i].id;
+
+        mPadMouseTouch.pointers[i].x += (mCurrentTouch.pointers[i].x - mLastTouch.pointers[i].x);
+        mPadMouseTouch.pointers[i].x = (mPadMouseTouch.pointers[i].x < mLocked.xOrigin)?mLocked.xOrigin:
+            ((mPadMouseTouch.pointers[i].x - mLocked.xOrigin >= mLocked.xRange)?(mLocked.xRange-1):mPadMouseTouch.pointers[i].x);
+
+        mPadMouseTouch.pointers[i].y += (mCurrentTouch.pointers[i].y - mLastTouch.pointers[i].y);
+        mPadMouseTouch.pointers[i].y = (mPadMouseTouch.pointers[i].y < mLocked.xOrigin)?mLocked.yOrigin:
+            ((mPadMouseTouch.pointers[i].y - mLocked.yOrigin >= mLocked.yRange)?(mLocked.yRange-1):mPadMouseTouch.pointers[i].y);
+
+        mPadMouseTouch.pointers[i].pressure = mCurrentTouch.pointers[i].pressure;
+        mPadMouseTouch.pointers[i].touchMajor = mCurrentTouch.pointers[i].touchMajor;
+        mPadMouseTouch.pointers[i].touchMinor = mCurrentTouch.pointers[i].touchMinor;
+        mPadMouseTouch.pointers[i].toolMajor = mCurrentTouch.pointers[i].toolMajor;
+        mPadMouseTouch.pointers[i].toolMinor = mCurrentTouch.pointers[i].toolMinor;
+        mPadMouseTouch.pointers[i].orientation = mCurrentTouch.pointers[i].orientation;
+
+        int id = mPadMouseTouch.pointers[i].id;
+        mPadMouseTouch.idToIndex[id] = mCurrentTouch.idToIndex[id];
     }
 }
 
@@ -2266,6 +2386,19 @@
     }
 }
 
+void TouchInputMapper::generateVirtualTouch(nsecs_t when, bool down){
+    int32_t motionEventAction = AMOTION_EVENT_ACTION_DOWN;
+    mMagicKeyDown = true;
+    if(!down)
+        motionEventAction = AMOTION_EVENT_ACTION_UP;
+
+    BitSet32 currentIdBits = mPadMouseTouch.idBits;
+    dispatchTouch(when, 0, & mPadMouseTouch,
+        currentIdBits, -1, 1, motionEventAction);
+    if(!down)
+        mMagicKeyDown = false;
+}
+
 void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) {
     uint32_t currentPointerCount = mCurrentTouch.pointerCount;
     uint32_t lastPointerCount = mLastTouch.pointerCount;
@@ -2280,8 +2413,14 @@
         // No pointer id changes so this is a move event.
         // The dispatcher takes care of batching moves so we don't have to deal with that here.
         int32_t motionEventAction = AMOTION_EVENT_ACTION_MOVE;
-        dispatchTouch(when, policyFlags, & mCurrentTouch,
+        if(mContext->isPadmouseOn()){
+            computeRelativePosition();
+            dispatchTouch(when, policyFlags, & mPadMouseTouch,
                 currentIdBits, -1, currentPointerCount, motionEventAction);
+        }else{
+            dispatchTouch(when, policyFlags, & mCurrentTouch,
+                currentIdBits, -1, currentPointerCount, motionEventAction);
+        }
     } else {
         // There may be pointers going up and pointers going down and pointers moving
         // all at the same time.
@@ -2320,12 +2459,18 @@
             int32_t motionEventAction;
             if (activeIdBits.isEmpty()) {
                 motionEventAction = AMOTION_EVENT_ACTION_UP;
+                mUpTime = when;
             } else {
                 motionEventAction = AMOTION_EVENT_ACTION_POINTER_UP;
             }
 
-            dispatchTouch(when, policyFlags, &interimTouch,
-                    oldActiveIdBits, upId, pointerCount, motionEventAction);
+            if(mContext->isPadmouseOn()){
+                dispatchTouch(when, policyFlags, & mPadMouseTouch,
+                    currentIdBits, -1, currentPointerCount, motionEventAction);
+            }else{
+                dispatchTouch(when, policyFlags, &interimTouch,
+                        oldActiveIdBits, upId, pointerCount, motionEventAction);
+            }
             pointerCount -= 1;
         }
 
@@ -2347,14 +2492,34 @@
             int32_t motionEventAction;
             if (oldActiveIdBits.isEmpty()) {
                 motionEventAction = AMOTION_EVENT_ACTION_DOWN;
+                mLastDownTime = mDownTime;
                 mDownTime = when;
+
+				if( mContext->isPadmouseOn() && mContext->isPadmouseDoubleClickEnable()){
+					if(mContext->isPadmouseOn())
+						LOGE("PadMouse double tap detecting...,Up2Dn(%lld), Dn2Up(%lld)", 
+						(ns2ms(mDownTime) - ns2ms(mUpTime)), (ns2ms(mUpTime) - ns2ms(mLastDownTime)));
+					
+					if ((ns2ms(mDownTime) - ns2ms(mUpTime) > mDoubleTapMinDurationUp2Dn) 
+						&& (ns2ms(mDownTime) -ns2ms(mUpTime) < mDoubleTapMaxDurationUp2Dn) 
+						&& (ns2ms(mUpTime) - ns2ms(mLastDownTime) > mDoubleTapMinDurationDn2Up)
+						&& (ns2ms(mUpTime) - ns2ms(mLastDownTime) < mDoubleTapMaxDurationDn2Up)) {
+						mDoubleClick = true;
+					}
+				}
+
             } else {
                 motionEventAction = AMOTION_EVENT_ACTION_POINTER_DOWN;
             }
 
             pointerCount += 1;
-            dispatchTouch(when, policyFlags, &mCurrentTouch,
+            if(mContext->isPadmouseOn()){
+                dispatchTouch(when, policyFlags, & mPadMouseTouch,
+                    currentIdBits, -1, currentPointerCount, motionEventAction);
+            } else {
+                dispatchTouch(when, policyFlags, &mCurrentTouch,
                     activeIdBits, downId, pointerCount, motionEventAction);
+            }
         }
     }
 }
@@ -2375,8 +2540,14 @@
         for (uint32_t outIndex = 0; ! idBits.isEmpty(); outIndex++) {
             uint32_t id = idBits.firstMarkedBit();
             idBits.clearBit(id);
-            uint32_t inIndex = touch->idToIndex[id];
-
+            uint32_t inIndex = touch->idToIndex[id];	  
+            if(mContext->isPadmouseOn()){
+			  if(inIndex != 0){
+			  	LOGD("dispatchTouch: crash traceing, ask frank.chen check this log");
+			  }
+			  inIndex = 0;
+            } 
+			 
             const PointerData& in = touch->pointers[inIndex];
 
             // X and Y
@@ -2506,7 +2677,8 @@
             }
 
             // Adjust coords for orientation.
-            switch (mLocked.surfaceOrientation) {
+            int32_t adjustedorientation = (mLocked.surfaceOrientation + mLocked.hwrotation) % 4;
+            switch (adjustedorientation) {
             case InputReaderPolicyInterface::ROTATION_90: {
                 float xTemp = x;
                 x = y;
@@ -2573,10 +2745,41 @@
         yPrecision = mLocked.orientedYPrecision;
     } // release lock
 
-    getDispatcher()->notifyMotion(when, getDeviceId(), getSources(), policyFlags,
+    if( mContext->isPadmouseOn() ){
+        if( (AMOTION_EVENT_ACTION_MOVE == motionEventAction) || mDoubleClick || mMagicKeyDown ){
+            int32_t pointerId = 0;
+            if(AMOTION_EVENT_ACTION_DOWN == motionEventAction){
+                if(mPadmouseDown)
+                    return;
+                else
+                    mPadmouseDown = true;
+            }else if(AMOTION_EVENT_ACTION_UP== motionEventAction){
+                 if(mPadmouseDown)
+                    mPadmouseDown = false;
+                 else
+                     return;
+            }
+            getDispatcher()->notifyMotion(when, getDeviceId(), AINPUT_SOURCE_MOUSE, 0,
+                motionEventAction, 0, getContext()->getGlobalMetaState(), AMOTION_EVENT_EDGE_FLAG_NONE,
+                1, &pointerId, pointerCoords,
+                1, 1, mDownTime);
+        }
+
+        if(AMOTION_EVENT_ACTION_UP == motionEventAction)
+            mDoubleClick = false;
+    }else{
+        getDispatcher()->notifyMotion(when, getDeviceId(), getSources(), policyFlags,
             motionEventAction, 0, getContext()->getGlobalMetaState(), motionEventEdgeFlags,
             pointerCount, pointerIds, pointerCoords,
             xPrecision, yPrecision, mDownTime);
+    }
+}
+
+bool TouchInputMapper::isPadmouseLeftKey(int32_t scanCode) {
+    if( mContext->isPadmouseOn() && (scanCode == mContext->getPadmouseMagicKey()) )
+        return true;
+    else
+        return false;
 }
 
 bool TouchInputMapper::isPointInsideSurfaceLocked(int32_t x, int32_t y) {
@@ -3280,6 +3483,16 @@
 }
 
 void MouseInputMapper::process(const RawEvent* rawEvent) {
+	char value[16];
+	int xoffset=0;
+	int yoffset=0;
+	if (property_get("hw.aipdisplay.flag", value, NULL) > 1) { 
+		
+		property_get("hw.aipdisplay.x", value, "0");
+	    xoffset = atoi(value);
+		property_get("hw.aipdisplay.y", value, "0");
+	    yoffset = atoi(value);
+	}
     switch (rawEvent->type) {
     case EV_KEY:
         switch (rawEvent->scanCode) {
@@ -3546,6 +3759,12 @@
             return;
         }
 
+        // Rotate motion based on display orientation if needed.
+        // Note: getDisplayInfo is non-reentrant so we can continue holding the lock.
+        if (false && mLocked.down)
+            LOGD("r rel x/y=%f/%f w/h=%d/%d orientation=%d",
+                 x, y, screenWidth, screenHeight, orientation);
+
         float temp;
         switch (orientation) {
         case InputReaderPolicyInterface::ROTATION_90:
@@ -3572,6 +3791,22 @@
             break;
         }
 
+        mAccumulator.absX = (mAccumulator.absX + x) > screenWidth ? screenWidth -1 : ((mAccumulator.absX + x) < 0 ? 0 : mAccumulator.absX + x);
+        mAccumulator.absY = (mAccumulator.absY + y) > screenHeight ? screenHeight -1 : ((mAccumulator.absY + y) < 0 ? 0 : mAccumulator.absY + y);
+
+        if (false && mLocked.down)
+            LOGD("c abs x/y=%d/%d w/h=%d/%d orientation=%d",
+                 mAccumulator.absX, mAccumulator.absY, screenWidth, screenHeight, orientation);
+        pointerCoords.x = mAccumulator.absX;
+        pointerCoords.y = mAccumulator.absY;
+        pointerCoords.pressure = mLocked.down ? 1.0f : 0.0f;
+        pointerCoords.size = 0;
+        pointerCoords.touchMajor = 0;
+        pointerCoords.touchMinor = 0;
+        pointerCoords.toolMajor = 0;
+        pointerCoords.toolMinor = 0;
+        pointerCoords.orientation = 0;
+
    } // release lock
 
    int32_t metaState = mContext->getGlobalMetaState();
@@ -3608,6 +3843,24 @@
     mY = 0;
     mPressure = 0; // default to 0 for devices that don't report pressure
     mToolWidth = 0; // default to 0 for devices that don't report tool width
+
+	mDoubleTapMinDurationDn2Up = MIN_DURATION_DOUBLE_TAP_DN2UP;
+	mDoubleTapMaxDurationDn2Up = MAX_DURATION_DOUBLE_TAP_DN2UP;
+	mDoubleTapMinDurationUp2Dn = MIN_DURATION_DOUBLE_TAP_UP2DN;
+	mDoubleTapMaxDurationUp2Dn = MAX_DURATION_DOUBLE_TAP_UP2DN;
+
+	char prop[PROPERTY_VALUE_MAX] = {0};
+    if(property_get("ro.padmouse.dn2up.min", prop, NULL)>0)
+		mDoubleTapMinDurationDn2Up = atoi(prop);
+	if(property_get("ro.padmouse.dn2up.max", prop, NULL)>0)
+		mDoubleTapMaxDurationDn2Up = atoi(prop);
+	if(property_get("ro.padmouse.up2dn.min", prop, NULL)>0)
+		mDoubleTapMinDurationUp2Dn = atoi(prop);
+	if(property_get("ro.padmouse.up2dn.max", prop, NULL)>0)
+		mDoubleTapMaxDurationUp2Dn = atoi(prop);
+
+
+
 }
 
 void SingleTouchInputMapper::reset() {
@@ -3627,6 +3880,10 @@
             // not have received valid position information yet.  This logic assumes that
             // BTN_TOUCH is always followed by SYN_REPORT as part of a complete packet.
             break;
+        default:
+            if(isPadmouseLeftKey(rawEvent->keyCode)){
+                generateVirtualTouch(rawEvent->when, (rawEvent->value != 0));
+            }
         }
         break;
 
@@ -3731,6 +3988,21 @@
 
 void MultiTouchInputMapper::initialize() {
     mAccumulator.clear();
+
+	mDoubleTapMinDurationDn2Up = MT_MIN_DURATION_DOUBLE_TAP_DN2UP;
+	mDoubleTapMaxDurationDn2Up = MT_MAX_DURATION_DOUBLE_TAP_DN2UP;
+	mDoubleTapMinDurationUp2Dn = MT_MIN_DURATION_DOUBLE_TAP_UP2DN;
+	mDoubleTapMaxDurationUp2Dn = MT_MAX_DURATION_DOUBLE_TAP_UP2DN;
+
+	char prop[PROPERTY_VALUE_MAX] = {0};
+	if(property_get("ro.padmouse.dn2up.min", prop, NULL)>0)
+		mDoubleTapMinDurationDn2Up = atoi(prop);
+	if(property_get("ro.padmouse.dn2up.max", prop, NULL)>0)
+		mDoubleTapMaxDurationDn2Up = atoi(prop);
+	if(property_get("ro.padmouse.up2dn.min", prop, NULL)>0)
+		mDoubleTapMinDurationUp2Dn = atoi(prop);
+	if(property_get("ro.padmouse.up2dn.max", prop, NULL)>0)
+		mDoubleTapMaxDurationUp2Dn = atoi(prop);
 }
 
 void MultiTouchInputMapper::reset() {
@@ -3740,7 +4012,23 @@
 }
 
 void MultiTouchInputMapper::process(const RawEvent* rawEvent) {
+	char value[16];
+	int xoffset=0;
+	int yoffset=0;
+	if (property_get("hw.aipdisplay.flag", value, NULL) > 1) { 
+		
+		property_get("hw.aipdisplay.x", value, "0");
+	    xoffset = atoi(value);
+		property_get("hw.aipdisplay.y", value, "0");
+	    yoffset = atoi(value);
+	}
     switch (rawEvent->type) {
+    case EV_KEY:
+        if(isPadmouseLeftKey(rawEvent->keyCode)){
+            generateVirtualTouch(rawEvent->when, (rawEvent->value != 0));
+        }
+        break;
+
     case EV_ABS: {
         uint32_t pointerIndex = mAccumulator.pointerCount;
         Accumulator::Pointer* pointer = & mAccumulator.pointers[pointerIndex];
