--- M4vH263Encoder.cpp.original	2012-02-09 22:22:07.000000000 +0100
+++ M4vH263Encoder.cpp.psquare	2012-02-09 15:45:08.000000000 +0100
@@ -31,7 +31,7 @@
 #include <media/stagefright/Utils.h>
 
 namespace android {
-
+#if 0
 inline static void ConvertYUV420SemiPlanarToYUV420Planar(
         uint8_t *inyuv, uint8_t* outyuv,
         int32_t width, int32_t height) {
@@ -61,6 +61,81 @@
         }
     }
 }
+#endif
+
+#ifdef AML_VIDEOENCODER_ROTATE
+inline static void ConvertYUV420SemiPlanarToYUV420Planar_Rotate(
+        uint8_t *inyuv, uint8_t* outyuv,
+        int32_t width, int32_t height, int32_t rotation) {
+
+    int32_t outYsize = width * height;
+    uint8_t* outy = (uint8_t*)outyuv;
+    uint8_t *outcb = (uint8_t *) (outyuv + outYsize);
+    uint8_t *outcr = (uint8_t *) (outyuv + outYsize + (outYsize >> 2));
+
+    /* Y copying */
+    if(rotation == 0){
+        memcpy(outy, inyuv, outYsize);
+    }else if(rotation == 90){
+        for (int32_t i=0; i<width; i++){
+            for (int32_t j=height-1; j>=0; j--){
+                *outy++ = inyuv[j*width+i];
+            }
+        } 
+    }else if(rotation == 180){
+        for (int32_t j=height-1; j>=0; j--){
+            for (int32_t i =width-1; i>=0; i--){
+                 *outy++ = inyuv[j*width+i];
+            }
+        }  
+    }else if(rotation == 270){
+        for (int32_t i =width-1; i>=0; i--){
+            for (int32_t j=0; j<height; j++){
+                *outy++ = inyuv[j*width+i];
+            }
+        }   
+    }else{
+        return;
+    }
+ 
+    /* U & V copying */
+    uint16_t* inyuv_cbcr = (uint16_t*)(inyuv + outYsize);
+    uint16_t temp_uv = 0;
+    if(rotation == 0){
+        for (int32_t j=0; j<(height>>1); j++){
+            for (int32_t i =0; i<(width>>1); i++){
+                temp_uv = inyuv_cbcr[j*(width>>1)+i];
+                *outcr++ = (temp_uv&0xff);
+                *outcb++ = (temp_uv&0xff00)>>8;
+            }
+        }  
+    }else if(rotation == 90){
+        for (int32_t i=0; i<(width>>1); i++){
+            for (int32_t j=(height>>1)-1; j>=0; j--){
+                temp_uv = inyuv_cbcr[j*(width>>1)+i];
+                *outcr++ = (temp_uv&0xff);
+                *outcb++ = (temp_uv&0xff00)>>8;
+            }
+        } 
+    }else if(rotation == 180){
+        for (int32_t j=(height>>1)-1; j>=0; j--){
+            for (int32_t i =(width>>1)-1; i>=0; i--){
+                temp_uv = inyuv_cbcr[j*(width>>1)+i];
+                *outcr++ = (temp_uv&0xff);
+                *outcb++ = (temp_uv&0xff00)>>8;
+            }
+        }  
+    }else if(rotation == 270){
+        for (int32_t i =(width>>1)-1; i>=0; i--){
+            for (int32_t j=0; j<(height>>1); j++){
+                temp_uv = inyuv_cbcr[j*(width>>1)+i];
+                *outcr++ = (temp_uv&0xff);
+                *outcb++ = (temp_uv&0xff00)>>8;
+            }
+        }   
+    }
+}
+#endif
 
 M4vH263Encoder::M4vH263Encoder(
         const sp<MediaSource>& source,
@@ -95,8 +170,37 @@
 
 status_t M4vH263Encoder::initCheck(const sp<MetaData>& meta) {
     LOGV("initCheck");
+
+    const char *mime;
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+    CHECK(!strcmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4) ||
+          !strcmp(mime, MEDIA_MIMETYPE_VIDEO_H263));
+
+#ifdef AML_VIDEOENCODER_ROTATE
+    CHECK(meta->findInt32(kKeyRotationDegree, &mVideoRotation));
+    if(!strcmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)){
+        if((mVideoRotation == 90)||(mVideoRotation == 270)){
+            CHECK(meta->findInt32(kKeyWidth, &mVideoHeight));
+            CHECK(meta->findInt32(kKeyHeight, &mVideoWidth));
+            mVideoRotateEnable = 1;
+        }else{
+            if(mVideoRotation == 180)
+                mVideoRotateEnable = 1;
+            else
+                mVideoRotateEnable = 0;
     CHECK(meta->findInt32(kKeyWidth, &mVideoWidth));
     CHECK(meta->findInt32(kKeyHeight, &mVideoHeight));
+        }
+    }else{
+        CHECK(meta->findInt32(kKeyWidth, &mVideoWidth));
+        CHECK(meta->findInt32(kKeyHeight, &mVideoHeight));
+        mVideoRotateEnable = 0;
+    }
+#else
+    CHECK(meta->findInt32(kKeyWidth, &mVideoWidth));
+    CHECK(meta->findInt32(kKeyHeight, &mVideoHeight));
+#endif
+
     CHECK(meta->findInt32(kKeySampleRate, &mVideoFrameRate));
     CHECK(meta->findInt32(kKeyBitRate, &mVideoBitRate));
 
@@ -131,10 +235,7 @@
     // Need to know which role the encoder is in.
     // XXX: Set the mode proper for other types of applications
     //      like streaming or video conference
-    const char *mime;
-    CHECK(meta->findCString(kKeyMIMEType, &mime));
-    CHECK(!strcmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4) ||
-          !strcmp(mime, MEDIA_MIMETYPE_VIDEO_H263));
+    
     if (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)) {
         mEncParams->encMode = COMBINE_MODE_WITH_ERR_RES;
     } else {
@@ -194,6 +295,10 @@
     mFormat->setInt32(kKeySampleRate, mVideoFrameRate);
     mFormat->setInt32(kKeyColorFormat, mVideoColorFormat);
 
+#ifdef AML_VIDEOENCODER_ROTATE
+    mFormat->setInt32(kKeyRotationDegree, mVideoRotation);
+#endif
+
     mFormat->setCString(kKeyMIMEType, mime);
     mFormat->setCString(kKeyDecoderComponent, "M4vH263Encoder");
     return OK;
@@ -329,8 +434,19 @@
     if (mVideoColorFormat != OMX_COLOR_FormatYUV420Planar) {
         CHECK(mInputFrameData);
         CHECK(mVideoColorFormat == OMX_COLOR_FormatYUV420SemiPlanar);
-        ConvertYUV420SemiPlanarToYUV420Planar(
-            inPtr, mInputFrameData, mVideoWidth, mVideoHeight);
+#ifdef AML_VIDEOENCODER_ROTATE
+        if(mVideoRotateEnable){
+            if((mVideoRotation == 90)||(mVideoRotation == 270)){
+                ConvertYUV420SemiPlanarToYUV420Planar_Rotate(inPtr, mInputFrameData, mVideoHeight, mVideoWidth,mVideoRotation);
+            }else{
+                ConvertYUV420SemiPlanarToYUV420Planar_Rotate(inPtr, mInputFrameData, mVideoWidth, mVideoHeight,mVideoRotation);
+            }
+        }else{
+            ConvertYUV420SemiPlanarToYUV420Planar(inPtr, mInputFrameData, mVideoWidth, mVideoHeight);
+        }
+#else
+        ConvertYUV420SemiPlanarToYUV420Planar(inPtr, mInputFrameData, mVideoWidth, mVideoHeight);
+#endif
         inPtr = mInputFrameData;
     }
     CHECK(inPtr != NULL);
