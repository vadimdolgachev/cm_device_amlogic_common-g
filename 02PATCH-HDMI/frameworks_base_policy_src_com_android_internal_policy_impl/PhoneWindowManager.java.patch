--- PhoneWindowManager.java.original	2012-02-28 01:34:22.000000000 +0100
+++ PhoneWindowManager.java.psquare	2012-02-28 04:20:40.000000000 +0100
@@ -123,6 +123,7 @@
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.List;
+import android.app.ActivityManager;
 
 /**
  * WindowManagerPolicy implementation for the Android phone UI.  This
@@ -212,6 +213,7 @@
     /** If true, hitting shift & menu will broadcast Intent.ACTION_BUG_REPORT */
     boolean mEnableShiftMenuBugReports = false;
 
+    boolean mInitReady = false;
     boolean mSafeMode;
     WindowState mStatusBar = null;
     final ArrayList<WindowState> mStatusBarPanels = new ArrayList<WindowState>();
@@ -226,9 +228,11 @@
     boolean mLidOpen;
     int mUiMode = Configuration.UI_MODE_TYPE_NORMAL;
     int mDockMode = Intent.EXTRA_DOCK_STATE_UNDOCKED;
+    int mTvOutMode = Intent.EXTRA_TVOUT_STATE_OFF;
     int mLidOpenRotation;
     int mCarDockRotation;
     int mDeskDockRotation;
+    int mTvOutRotation;
 
     int mUserRotationMode = WindowManagerPolicy.USER_ROTATION_FREE;
     int mUserRotation = Surface.ROTATION_0;
@@ -236,6 +240,8 @@
     boolean mAllowAllRotations;
     boolean mCarDockEnablesAccelerometer;
     boolean mDeskDockEnablesAccelerometer;
+    boolean mTvOutEnablesAccelerometer;
+    boolean mLandscapeAutoSelectClockwise = true;
     int mLidKeyboardAccessibility;
     int mLidNavigationAccessibility;
     boolean mScreenOn = false;
@@ -244,10 +250,13 @@
     int mCurrentAppOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
     static final int DEFAULT_ACCELEROMETER_ROTATION = 0;
     int mAccelerometerDefault = DEFAULT_ACCELEROMETER_ROTATION;
+    int mForceRotation = 0;
+    int mForceRotationTo = 0;
     boolean mHasSoftInput = false;
     boolean mCameraKeyPressable = false;
     static final long NEXT_DURATION = 400;
     private boolean mBottomBar;
+    boolean mAllowAllOrientations = false;
     int mPointerLocationMode = 0;
     PointerLocationView mPointerLocationView = null;
     InputChannel mPointerLocationInputChannel;
@@ -349,6 +358,10 @@
                     Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this);
             resolver.registerContentObserver(Settings.System.getUriFor(
                     Settings.System.ACCELEROMETER_ROTATION), false, this);
+//            resolver.registerContentObserver(Settings.System.getUriFor(
+//                    Settings.System.FORCE_ROTATION), false, this);
+//            resolver.registerContentObserver(Settings.System.getUriFor(
+//                    Settings.System.FORCE_ROTATION_DIRECTION), false, this);
             resolver.registerContentObserver(Settings.System.getUriFor(
                     Settings.System.SCREEN_OFF_TIMEOUT), false, this);
             resolver.registerContentObserver(Settings.System.getUriFor(
@@ -417,7 +430,8 @@
         }
         // We're in a dock that has a rotation affinity, and the app is willing to rotate.
         if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR)
-                || (mDeskDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_DESK)) {
+                || (mDeskDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_DESK)
+                || (mTvOutEnablesAccelerometer && mTvOutMode == Intent.EXTRA_TVOUT_STATE_ON)) {
             // Note we override the nosensor flag here.
             if (appOrientation == ActivityInfo.SCREEN_ORIENTATION_USER
                     || appOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
@@ -444,11 +458,17 @@
             return true;
         }
         if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR) ||
-                (mDeskDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_DESK)) {
+            (mDeskDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_DESK) ||
+            (mTvOutEnablesAccelerometer && mTvOutMode == Intent.EXTRA_TVOUT_STATE_ON)) {
             // enable accelerometer if we are docked in a dock that enables accelerometer
             // orientation management,
             return true;
         }
+
+        if (mForceRotation != 0){
+            return false;
+        }
+        
         if (mAccelerometerDefault == 0) {
             // If the setting for using the sensor by default is enabled, then
             // we will always leave it on.  Note that the user could go to
@@ -747,10 +767,16 @@
                 com.android.internal.R.integer.config_deskDockRotation);
         mAllowAllRotations = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_allowAllRotations);
+//        mTvOutRotation = readRotation(
+//                com.android.internal.R.integer.config_TvOutRotation);
         mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_carDockEnablesAccelerometer);
         mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
+//        mTvOutEnablesAccelerometer = mContext.getResources().getBoolean(
+//                com.android.internal.R.bool.config_TvOutEnablesAccelerometer);
+//        mLandscapeAutoSelectClockwise = mContext.getResources().getBoolean(
+//                com.android.internal.R.bool.config_landscape_auto_select_clockwise);
         mLidKeyboardAccessibility = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_lidKeyboardAccessibility);
         mLidNavigationAccessibility = mContext.getResources().getInteger(
@@ -762,11 +788,14 @@
         filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
         filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
         filter.addAction(Intent.ACTION_DOCK_EVENT);
+        filter.addAction(Intent.ACTION_TVOUT_EVENT);
         Intent intent = context.registerReceiver(mDockReceiver, filter);
         if (intent != null) {
             // Retrieve current sticky dock event broadcast.
             mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
                     Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            mTvOutMode = intent.getIntExtra(Intent.EXTRA_TVOUT_STATE,
+                    Intent.EXTRA_TVOUT_STATE_OFF);
         }
         mVibrator = new Vibrator();
         mLongPressVibePattern = loadHaptic(HapticFeedbackConstants.LONG_PRESS);
@@ -777,6 +806,8 @@
         mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(),
                 com.android.internal.R.array.config_safeModeEnabledVibePattern);
         mVirtualKeyUpVibePattern = loadHaptic(HapticFeedbackConstants.VIRTUAL_RELEASED);
+        mAllowAllOrientations = SystemProperties.getBoolean("allow_all_orientations", false);
+        mInitReady = true;
     }
 
     public void updateSettings() {
@@ -810,6 +841,18 @@
                 mAccelerometerDefault = accelerometerDefault;
                 updateOrientationListenerLp();
             }
+
+//            int forceRotationTo = Settings.System.getInt(resolver,
+//                    Settings.System.FORCE_ROTATION_DIRECTION, 0);  
+            
+//            int forceRotation = Settings.System.getInt(resolver,
+//                    Settings.System.FORCE_ROTATION, 0);
+            
+//            if (mForceRotation != forceRotation || mForceRotationTo != forceRotationTo ) {
+//                mForceRotation = forceRotation;
+//                mForceRotationTo = forceRotationTo;
+//                updateOrientationListenerLp();
+//            }
             if (mSystemReady) {
                 int pointerLocation = Settings.System.getInt(resolver,
                         Settings.System.POINTER_LOCATION, 0);
@@ -1277,6 +1320,30 @@
             WindowManager.LayoutParams.TYPE_SYSTEM_ERROR,
         };
 
+    private static final String KEY_DOWN_HAPPEN = "com.android.internal.policy.impl.KEY_DOWN_HAPPEN";
+    private static final String START_TVSETSERVICE = "com.tv.TvSetup.TvSetupService";
+	private static final String TV_MENU_STOP = "com.amlogic.tv.tvmenu.stop";
+    public static boolean isServiceRunning(Context mContext,String className) {
+        boolean isRunning = false;
+        ActivityManager activityManager = (ActivityManager)
+        mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningServiceInfo> serviceList
+            = activityManager.getRunningServices(30);
+
+        if (!(serviceList.size()>0)) {
+            return false;
+        }
+
+        for (int i=0; i<serviceList.size(); i++) {
+            if (serviceList.get(i).service.getClassName().equals(className) == true) {
+                isRunning = true;
+                break;
+            }
+        }
+
+        return isRunning;
+    }
+    
     /** {@inheritDoc} */
     @Override
     public boolean interceptKeyBeforeDispatching(WindowState win, int action, int flags,
@@ -1290,6 +1357,21 @@
                     + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed);
         }
 
+        if(SystemProperties.getBoolean("ro.tv.shortcutkey", false)) {
+         	  if(SystemProperties.getBoolean("dev.tv.tvstart_status", false)&&(keyCode == KeyEvent.KEYCODE_HOME)) {
+         	  	Intent stoptv=new Intent(TV_MENU_STOP);
+         	    mContext.sendBroadcast(stoptv);
+         	  }
+            if(SystemProperties.getBoolean("dev.tv.globalsetup_show_status", false)||(keyCode == KeyEvent.KEYCODE_VOLUME_UP)||(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) { //||(keyCode == KeyEvent.KEYCODE_TV_SYSTEM)||(keyCode == KeyEvent.KEYCODE_MEDIA_SUB_T)
+                if(down) {
+                    Intent intent1=new Intent(KEY_DOWN_HAPPEN);
+                    intent1.putExtra("keyNum",keyCode);
+                    mContext.sendBroadcast(intent1);  
+                }
+                return true;
+            }
+        }
+
         // Clear a pending HOME longpress if the user releases Home
         // TODO: This could probably be inside the next bit of logic, but that code
         // turned out to be a bit fragile so I'm doing it here explicitly, for now.
@@ -1352,7 +1434,7 @@
             if (attrs != null) {
                 final int type = attrs.type;
                 if (type == WindowManager.LayoutParams.TYPE_KEYGUARD
-                        || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
+                        || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) { //|| type == WindowManager.LayoutParams.TYPE_APPLICATION_KEYGUARD)
                     // the "app" is keyguard, so give it the key
                     return false;
                 }
@@ -2348,6 +2430,9 @@
             if (Intent.ACTION_DOCK_EVENT.equals(intent.getAction())) {
                 mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
                         Intent.EXTRA_DOCK_STATE_UNDOCKED);
+            }else if (Intent.ACTION_TVOUT_EVENT.equals(intent.getAction())) {
+                mTvOutMode = intent.getIntExtra(Intent.EXTRA_TVOUT_STATE,
+                        Intent.EXTRA_TVOUT_STATE_OFF);
             } else {
                 try {
                     IUiModeManager uiModeService = IUiModeManager.Stub.asInterface(
@@ -2433,10 +2518,16 @@
     public int rotationForOrientationLw(int orientation, int lastRotation,
             boolean displayEnabled) {
 
+        if (!mInitReady) {
+            if (DEBUG) Log.d(TAG, "Init not ready!");
+            return Surface.ROTATION_0;
+        }
+
         if (mPortraitRotation < 0) {
             // Initialize the rotation angles for each orientation once.
             Display d = ((WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE))
                     .getDefaultDisplay();
+            if (mLandscapeAutoSelectClockwise) {
             if (d.getWidth() > d.getHeight()) {
                 mPortraitRotation = Surface.ROTATION_90;
                 mLandscapeRotation = Surface.ROTATION_0;
@@ -2448,9 +2539,34 @@
                 mUpsideDownRotation = Surface.ROTATION_180;
                 mSeascapeRotation = Surface.ROTATION_270;
             }
+            } else {
+                if (d.getWidth() > d.getHeight()) {
+                    mPortraitRotation = Surface.ROTATION_90;
+                    mLandscapeRotation = Surface.ROTATION_0;
+                    mUpsideDownRotation = Surface.ROTATION_270;
+                    mSeascapeRotation = Surface.ROTATION_180;
+                } else {
+                    mPortraitRotation = Surface.ROTATION_0;
+                    mLandscapeRotation = Surface.ROTATION_270;
+                    mUpsideDownRotation = Surface.ROTATION_180;
+                    mSeascapeRotation = Surface.ROTATION_90;
+                }
+            }
         }
 
         synchronized (mLock) {
+            if( false == SystemProperties.getBoolean("hw.has.accelerometer", true) ){
+                switch (orientation) {
+                    case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
+                    case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
+                    case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
+                    case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
+                    case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
+                    case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
+                        return mLandscapeRotation;
+                }
+            }
+            
             switch (orientation) {
                 case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                     //always return portrait if orientation set to portrait
@@ -2475,18 +2591,31 @@
                     return getCurrentPortraitRotation(lastRotation);
             }
 
-            mOrientationListener.setAllow180Rotation(mAllowAllRotations ||
+            mOrientationListener.setAllow180Rotation(mAllowAllRotations || mAllowAllOrientations ||
                     orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 
             // case for nosensor meaning ignore sensor and consider only lid
             // or orientation sensor disabled
             //or case.unspecified
-            if (mLidOpen) {
+            if (mTvOutMode == Intent.EXTRA_TVOUT_STATE_ON && mTvOutRotation >= 0) {
+                return mTvOutRotation;
+            }else if (mLidOpen) {
                 return mLidOpenRotation;
             } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && mCarDockRotation >= 0) {
                 return mCarDockRotation;
             } else if (mDockMode == Intent.EXTRA_DOCK_STATE_DESK && mDeskDockRotation >= 0) {
                 return mDeskDockRotation;
+            } else if (mForceRotation != 0){
+                switch(mForceRotationTo){
+                    case 90:
+                        return Surface.ROTATION_90;
+                    case 180:
+                        return Surface.ROTATION_180;
+                    case 270:
+                        return Surface.ROTATION_270;
+                    default:
+                        return Surface.ROTATION_0;
+                }
             } else {
                 if (useSensorForOrientationLp(orientation)) {
                     return mOrientationListener.getCurrentRotation(lastRotation);
@@ -2627,7 +2756,9 @@
     void updateRotation(int animFlags) {
         mPowerManager.setKeyboardVisibility(mLidOpen);
         int rotation = Surface.ROTATION_0;
-        if (mLidOpen) {
+        if (mTvOutMode == Intent.EXTRA_TVOUT_STATE_ON && mTvOutRotation >= 0) {
+            rotation = mTvOutRotation;
+        }else if (mLidOpen) {
             rotation = mLidOpenRotation;
         } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && mCarDockRotation >= 0) {
             rotation = mCarDockRotation;
