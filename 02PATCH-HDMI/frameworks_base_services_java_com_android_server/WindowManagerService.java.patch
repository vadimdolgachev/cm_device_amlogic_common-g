--- WindowManagerService.java.original	2012-02-23 18:57:45.000000000 +0100
+++ WindowManagerService.java.psquare	2012-02-28 04:47:34.000000000 +0100
@@ -17,6 +17,9 @@
 
 package com.android.server;
 
+//import static android.view.WindowManager.MOUSE_CURSOR_NONE;
+//import static android.view.WindowManager.MOUSE_CURSOR_SURFACE;
+//import static android.view.WindowManager.MOUSE_CURSOR_OSD2;
 import static android.view.WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW;
 import static android.view.WindowManager.LayoutParams.FIRST_SUB_WINDOW;
 import static android.view.WindowManager.LayoutParams.FLAG_BLUR_BEHIND;
@@ -31,6 +34,7 @@
 import static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
 import static android.view.WindowManager.LayoutParams.LAST_SUB_WINDOW;
 import static android.view.WindowManager.LayoutParams.MEMORY_TYPE_PUSH_BUFFERS;
+//import static android.view.WindowManager.LayoutParams.MEMORY_TYPE_NO_BLEND;
 import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
 import static android.view.WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
 import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;
@@ -38,6 +42,7 @@
 import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
 
 import com.android.internal.app.IBatteryStats;
+//import com.android.internal.graphics.OSD2Cursor;
 import com.android.internal.policy.PolicyManager;
 import com.android.internal.policy.impl.CmPhoneWindowManager;
 import com.android.internal.policy.impl.PhoneWindowManager;
@@ -65,6 +70,7 @@
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
+import android.graphics.Path;
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.Region;
@@ -263,12 +269,22 @@
     final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
+        	if(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED.equals(intent.getAction())){
+				
             mPolicy.enableKeyguard(true);
             synchronized(mKeyguardTokenWatcher) {
                 // lazily evaluate this next time we're asked to disable keyguard
                 mAllowDisableKeyguard = ALLOW_DISABLE_UNKNOWN;
                 mKeyguardDisabled = false;
             }
+			}else if (Intent.ACTION_TVOUT_EVENT.equals(intent.getAction())) {
+
+				mTVOutOn = (intent.getIntExtra(Intent.EXTRA_TVOUT_STATE,
+                    Intent.EXTRA_TVOUT_STATE_OFF) == Intent.EXTRA_TVOUT_STATE_ON);
+
+				Slog.i("WindowManagerService ", "TvOut Intent receiver, tvout status="+ mTVOutOn);
+//				mInputManager.setTvOutStatus(mTVOutOn);
+			}
         }
     };
 
@@ -386,7 +402,22 @@
     boolean mBlurShown;
     Watermark mWatermark;
     ScreenRotationAnimation mScreenRotationAnimation;
+/*
+    //private static final int CURSOR_NONE = 0;
+    //private static final int CURSOR_GLSURFACE = 1;
+    //private static final int CURSOR_OSD2 = 2;
+    private final Object mMouseCursorLock = new Object();
+    private int mMouseCursorType;
+    private Surface mMouseSurface = null;
+    private boolean mMouseCursorShown = false;
+    private int mMlx;
+    private int mMly;
+    //private int mMlw;
+    //private int mMlh;
 
+	private final boolean mAutoHideCursor;
+	private final int mAutoHideCursorTimeout;
+*/
     int mTransactionSequence = 0;
 
     final float[] mTmpFloats = new float[9];
@@ -445,6 +476,7 @@
     Display mDisplay;
 
     H mH = new H();
+//	CursorRunable mCursorRunable = new CursorRunable();
 
     WindowState mCurrentFocus = null;
     WindowState mLastFocus = null;
@@ -489,6 +521,8 @@
 
     PowerManagerService mPowerManager;
 
+	private boolean mTVOutOn = false;
+
     float mWindowAnimationScale = 1.0f;
     float mTransitionAnimationScale = 1.0f;
 
@@ -660,12 +694,30 @@
         // Track changes to DevicePolicyManager state so we can enable/disable keyguard.
         IntentFilter filter = new IntentFilter();
         filter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
-        mContext.registerReceiver(mBroadcastReceiver, filter);
+		filter.addAction(Intent.ACTION_TVOUT_EVENT);
+        Intent intent = mContext.registerReceiver(mBroadcastReceiver, filter);
+		
+		if (intent != null) {
+            // Retrieve current sticky tvout event broadcast.
+			mTVOutOn = (intent.getIntExtra(Intent.EXTRA_TVOUT_STATE,
+                    Intent.EXTRA_TVOUT_STATE_OFF) == Intent.EXTRA_TVOUT_STATE_ON);
+        }
 
         mHoldingScreenWakeLock = pmc.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,
                 "KEEP_SCREEN_ON_FLAG");
         mHoldingScreenWakeLock.setReferenceCounted(false);
+/*
+        String mouseCursorTypeStr = SystemProperties.get("ro.ui.cursor");
+        if ("none".equals(mouseCursorTypeStr))
+            mMouseCursorType = MOUSE_CURSOR_NONE;
+        else if ("osd2".equals(mouseCursorTypeStr))
+            mMouseCursorType = MOUSE_CURSOR_OSD2;
+        else
+            mMouseCursorType = MOUSE_CURSOR_SURFACE;
 
+		mAutoHideCursor = SystemProperties.getBoolean("ro.ui.cursor.autohide", true);
+		mAutoHideCursorTimeout = SystemProperties.getInt("ro.ui.cursor.timeout", 10000);
+*/
         mInputManager = new InputManager(context, this);
 
         PolicyThread thr = new PolicyThread(mPolicy, this, context, pm);
@@ -4616,6 +4668,8 @@
                     Surface.setOrientation(0, rotation, animFlags);
                 }
             }
+            /*if (mMouseCursorType == CURSOR_OSD2)*/
+//                OSD2Cursor.setRotation((short)rotation);
             for (int i=mWindows.size()-1; i>=0; i--) {
                 WindowState w = mWindows.get(i);
                 if (w.mSurface != null) {
@@ -5057,6 +5111,7 @@
      * that to config-changed listeners if appropriate.
      */
     void sendNewConfiguration() {
+//        setMouseCursorVisibility(false);
         try {
             mActivityManager.updateConfiguration(null);
         } catch (RemoteException e) {
@@ -5472,6 +5527,12 @@
         private void updateInputDispatchModeLw() {
             mInputManager.setInputDispatchMode(mInputDispatchEnabled, mInputDispatchFrozen);
         }
+
+/*
+        public void handleCursorMotion(int x, int y) {
+            moveMouseCursor(x, y);
+        }
+*/
     }
 
     public void pauseKeyDispatching(IBinder _token) {
@@ -5512,6 +5573,46 @@
             mInputMonitor.setEventDispatchingLw(enabled);
         }
     }
+/*
+    public void moveMouseCursor(int x, int y) {
+        synchronized (mMouseCursorLock) {
+            if (mMlx != x || mMly != y) {
+                mMlx = x;
+                mMly = y;
+
+                if (mMouseCursorType == MOUSE_CURSOR_SURFACE) {
+                    if (mMouseSurface != null)
+                        requestAnimationLocked(0);
+                } else if (mMouseCursorType == MOUSE_CURSOR_OSD2) {
+                    OSD2Cursor.setPosition((short)x, (short)y);
+                    if (!mMouseCursorShown) {
+                        OSD2Cursor.show();
+                    }
+                }
+                if (!mMouseCursorShown)
+                    mMouseCursorShown = true;
+
+                if(mAutoHideCursor){
+                    mH.removeCallbacks(mCursorRunable);
+                    mH.postDelayed(mCursorRunable, mAutoHideCursorTimeout);
+                }
+            }
+        }
+    }
+
+    private void setMouseCursorVisibility(boolean show) {
+        synchronized (mMouseCursorLock) {
+            if (mMouseCursorType == MOUSE_CURSOR_SURFACE) {
+                mMouseCursorShown = show;
+                requestAnimationLocked(0);
+            } else if (mMouseCursorType == MOUSE_CURSOR_OSD2) {
+                if (show)
+                    OSD2Cursor.show();
+                else
+                    OSD2Cursor.hide();
+                mMouseCursorShown = show;
+            }
+*/
 
     /**
      * Injects a keystroke event into the UI.
@@ -6397,6 +6498,10 @@
                     flags |= Surface.PUSH_BUFFERS;
                 }
 
+//                if (mAttrs.memoryType == MEMORY_TYPE_NO_BLEND) {
+//                    flags |= Surface.NO_BLEND;
+//                }
+
                 if ((mAttrs.flags&WindowManager.LayoutParams.FLAG_SECURE) != 0) {
                     flags |= Surface.SECURE;
                 }
@@ -6895,6 +7000,10 @@
                 mDsDx = tmpFloats[Matrix.MSCALE_X];
                 mDtDx = tmpFloats[Matrix.MSKEW_Y];
                 mDsDy = tmpFloats[Matrix.MSKEW_X];
+/* amlogic
+                mDtDx = tmpFloats[Matrix.MSKEW_X];
+                mDsDy = tmpFloats[Matrix.MSKEW_Y];
+*/
                 mDtDy = tmpFloats[Matrix.MSCALE_Y];
                 int x = (int)tmpFloats[Matrix.MTRANS_X] + mXOffset;
                 int y = (int)tmpFloats[Matrix.MTRANS_Y] + mYOffset;
@@ -7888,7 +7997,28 @@
             icon = _icon;
         }
     }
-
+/*
+	private final class CursorRunable implements Runnable{
+		public void run() {
+            synchronized (mMouseCursorLock) {
+                if (mMouseCursorType == MOUSE_CURSOR_OSD2) {
+                    OSD2Cursor.hide();
+                    mMouseCursorShown = false;
+                }
+                else if (mMouseCursorType == MOUSE_CURSOR_SURFACE) {
+                    synchronized (mWindowMap) {
+                        if (mMouseSurface != null) {
+                            mMouseSurface.openTransaction();
+                            mMouseSurface.hide();
+                            mMouseSurface.closeTransaction();
+			    mMouseCursorShown = false;
+                        }
+		    }
+                }
+	    }
+	}
+    }
+*/
     private final class H extends Handler {
         public static final int REPORT_FOCUS_CHANGE = 2;
         public static final int REPORT_LOSING_FOCUS = 3;
@@ -8282,6 +8412,35 @@
         }
         return false;
     }
+/*
+    public int getMouseCursorType() {
+        synchronized (mMouseCursorLock) {
+            return mMouseCursorType;
+        }
+    }
+
+    public int setMouseCursorType(int type) {
+        synchronized (mMouseCursorLock) {
+            if (mMouseCursorShown) {
+                // hide old cursor
+                if (mMouseCursorType == MOUSE_CURSOR_OSD2) {
+                     OSD2Cursor.hide();
+                } else if (mMouseCursorType  == MOUSE_CURSOR_SURFACE) {
+                    synchronized (mWindowMap) {
+                        if (mMouseSurface != null) {
+                            mMouseSurface.openTransaction();
+                            mMouseSurface.hide();
+                            mMouseSurface.closeTransaction();
+                        }
+                    }
+                }
+            }
+            // let new cursor be redrawn in InputDispatcher
+            mMouseCursorShown = false;
+            mMouseCursorType = type;
+            return type;
+        }
+*/
 
     // -------------------------------------------------------------
     // Internals
@@ -8642,6 +8801,64 @@
             mFxSession = new SurfaceSession();
             createWatermark = true;
         }
+/*
+	synchronized(mMouseCursorLock){
+            if (mMouseCursorType == MOUSE_CURSOR_SURFACE) {
+                if(mMouseSurface == null){
+                    int x, y, w, h;
+                    Canvas canvas;
+                    Path path = new Path();
+                    w = 12;
+                    h = 20;
+                    x = (mDisplay.getWidth() - w) / 2;
+                    y = (mDisplay.getHeight() - h) / 2;
+                    try {
+                         //First Mouse event, create Surface
+                         mMouseSurface =
+                             new Surface(mFxSession,
+                                     0, -1, w, h,
+                                     PixelFormat.TRANSPARENT,
+                                     Surface.FX_SURFACE_NORMAL);
+                        canvas = mMouseSurface.lockCanvas(null);
+                        Paint tPaint = new Paint();
+                        tPaint.setStyle(Paint.Style.STROKE);
+                        tPaint.setStrokeWidth(2);
+                        tPaint.setColor(0xffffffff);
+                        path.moveTo(0.0f, 0.0f);
+                        path.lineTo(12.0f, 12.0f);
+                        path.lineTo(7.0f, 12.0f);
+                        path.lineTo(11.0f, 20.0f);
+                        path.lineTo(8.0f, 21.0f);
+                        path.lineTo(4.0f, 13.0f);
+                        path.lineTo(0.0f, 17.0f);
+                        path.close();
+                        canvas.clipPath(path);
+                        canvas.drawColor(0xff000000);
+                        canvas.drawPath(path, tPaint);
+
+                        mMouseSurface.unlockCanvasAndPost(canvas);
+
+                        synchronized(mWindowMap){
+                            mMouseSurface.openTransaction();
+                            mMouseSurface.setSize(w, h);
+                            mMouseSurface.closeTransaction();
+                        }
+                    } catch (Exception e) {
+                        Slog.e(TAG, "Exception creating mouse surface",e);
+                    }
+                    mMlx = x;
+                    mMly = y;
+                    //mMlw = w;
+                    //mMlh = h;
+                }
+            } else if (mMouseCursorType == MOUSE_CURSOR_OSD2) {
+                OSD2Cursor.setDisplaySize((short)dw, (short)dh);
+                mMlx = dw / 2;
+                mMly = dh / 2;
+            }
+	}
+*/
+
 
         if (SHOW_TRANSACTIONS) Slog.i(TAG, ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
 
@@ -9364,7 +9581,22 @@
                             w.mLastFrame.set(w.mFrame);
                             w.mLastContentInsets.set(w.mContentInsets);
                             w.mLastVisibleInsets.set(w.mVisibleInsets);
-                            makeWindowFreezingScreenIfNeededLocked(w);
+                            // If the screen is currently frozen, then keep
+                            // it frozen until this window draws at its new
+                            // orientation.
+                            if (mDisplayFrozen) {
+                                if (DEBUG_ORIENTATION) Slog.v(TAG,
+                                        "Resizing while display frozen: " + w);
+                                w.mOrientationChanging = true;
+                                if (!mWindowsFreezingScreen) {
+                                    mWindowsFreezingScreen = true;
+                                    // XXX should probably keep timeout from
+                                    // when we first froze the display.
+                                    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
+                                    mH.sendMessageDelayed(mH.obtainMessage(
+                                            H.WINDOW_FREEZE_TIMEOUT), 2000);
+                                }
+                            }
                             // If the orientation is changing, then we need to
                             // hold off on unfreezing the display until this
                             // window has been redrawn; to do that, we need
